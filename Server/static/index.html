<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>One-Diagram with Select Dropdown</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            background-color: #f0f4ff;
            margin: 0;
            padding: 20px;
        }
        header {
            text-align: center;
            font-size: 24px;
            margin-bottom: 20px;
        }
        .container {
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        .controls-container, .result-container {
            margin-bottom: 20px;
            width: 80%;
            text-align: center;
        }
        #diagramObject {
            border: 2px solid black;
            border-radius: 10px;
            width: 90%;
            height: 600px;
            display: none; /* пока не сгенерируем диаграмму */
        }
        input, button, select {
            padding: 10px;
            font-size: 16px;
            margin: 5px;
        }
        .result-box {
            padding: 10px;
            border: 1px solid #ccc;
            background-color: #fff;
            font-family: monospace;
            white-space: pre-wrap;
            text-align: left;
        }
    </style>
</head>
<body>
    <header>Formalne jazyky — Single Diagram + Dropdown</header>

    <div class="container">
        <!-- Управление -->
        <div class="controls-container">
            <!-- Ввод регулярки и генерация диаграммы -->
            <div>
                <label for="regex-input">Your regular expression:</label>
                <input type="text" id="regex-input" placeholder="Enter regex">
                <button id="send-regex-btn">Generate diagram</button>
            </div>

            <!-- Шаги по символу -->
            <div id="transition-part" style="display:none;">
                <label for="transition-select">Transition symbol:</label>
                <select id="transition-select"></select>
                <button id="send-transition-btn">Step by symbol</button>
            </div>
        </div>

        <!-- Место, куда загружается диаграмма -->
        <object id="diagramObject" type="image/svg+xml"></object>

        <!-- Результат -->
        <div class="result-container" id="result-container" style="display:none;">
            <h2>Result of transition</h2>
            <div id="result-box" class="result-box">State info here</div>
        </div>
    </div>

    <!-- Подключаем D3.js -->
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <script>
        let currentNeededIds = []; // куда ставим точки
        let svgDoc = null;         // DOM SVG после загрузки
        let currentRegex = "";     // текущее (модифицированное) регулярное выражение

        // При "Generate diagram"
        document.getElementById('send-regex-btn').addEventListener('click', async () => {
            const regexValue = document.getElementById('regex-input').value.trim();
            if (!regexValue) {
                alert("Введите регулярное выражение!");
                return;
            }

            // Отправляем POST /generate-regex
            const response = await fetch('/generate-regex', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ diagram_data: regexValue })
            });
            if (!response.ok) {
                alert("Ошибка при генерации диаграммы.");
                return;
            }
            const data = await response.json();
            // data = { diagram_url, highlight_ids, available_symbols }
            currentNeededIds = data.highlight_ids || [];
            updateTransitionSelect(data.available_symbols || []);

            const objEl = document.getElementById('diagramObject');
            objEl.style.display = 'block';
            objEl.data = data.diagram_url;

            // Когда .svg загрузится
            objEl.addEventListener('load', function onLoad() {
                objEl.removeEventListener('load', onLoad);
                svgDoc = objEl.contentDocument;
                if (!svgDoc) {
                    console.log("Не удалось получить contentDocument (CORS?).");
                    return;
                }
                // Рисуем точки
                redrawHighlights();
            });

            // Показываем панель переходов
            document.getElementById('transition-part').style.display = 'block';
        });

        // При "Step by symbol"
        document.getElementById('send-transition-btn').addEventListener('click', async () => {
            // Берём символ из выпадающего списка
            const select = document.getElementById('transition-select');
            const chosenSymbol = select.value;
            if (!chosenSymbol) {
                alert("Нет доступных символов для перехода!");
                return;
            }

            // Отправляем POST /generate-transition
            const response = await fetch('/generate-transition', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ transition: chosenSymbol })
            });
            if (!response.ok) {
                alert("Ошибка при шаге.");
                return;
            }

            const data = await response.json();
            // data = { highlight_ids, updated_regex, available_symbols }
            currentNeededIds = data.highlight_ids || [];
            currentRegex = data.updated_regex || "";
            updateTransitionSelect(data.available_symbols || []);

            // Обновляем поле результата
            const resultBox = document.getElementById('result-box');
            resultBox.textContent = `New state: ${currentRegex}`;
            document.getElementById('result-container').style.display = 'block';

            // Перерисовываем точки (старые стираем, новые ставим)
            redrawHighlights();
        });

        // Заполнение <select> с символами
        function updateTransitionSelect(symbols) {
            const select = document.getElementById('transition-select');
            select.innerHTML = ""; // очистить

            if (symbols.length === 0) {
                // Если нет возможных переходов, добавим пустую опцию
                const opt = document.createElement('option');
                opt.value = "";
                opt.textContent = "(no transitions)";
                select.appendChild(opt);
                select.disabled = true;
            } else {
                select.disabled = false;
                symbols.forEach(sym => {
                    const opt = document.createElement('option');
                    opt.value = sym;
                    opt.textContent = sym;
                    select.appendChild(opt);
                });
            }
        }

function redrawHighlights() {
    if (!svgDoc) return;

    // 1) Удаляем все старые кружки
    d3.select(svgDoc).selectAll('circle.hl-dot').remove();

    // 2) Проходимся по всем neededIds
    currentNeededIds.forEach(termId => {

        if (termId !== 100) {
            // Обычная логика для "обычных" ID — рисуем точку у <rect> внутри g[id="...]"
            const g = d3.select(svgDoc).select(`g[id="${termId}"]`);
            if (!g.empty()) {
                const rect = g.select('rect');
                if (!rect.empty()) {
                    const x = +rect.attr('x');
                    const y = +rect.attr('y');
                    const h = +rect.attr('height');
                    const cx = x - 8;
                    const cy = y + (h / 2);
                    g.append('circle')
                     .attr('class', 'hl-dot')
                     .attr('cx', cx)
                     .attr('cy', cy)
                     .attr('r', 4)
                     .attr('fill', 'red');
                }
            }
        }
        else {
            // === termId == 100 => точка в самом конце последнего path ===

            // 1) Ищем верхний контейнер <g transform="translate(.5 .5)">
            //    (или другой, где лежат основные группы/пути)
            const topG = d3.select(svgDoc).select('g[transform]');
            if (topG.empty()) {
                console.log("Не нашли верхний <g transform='...'> для id=100");
                return;
            }

            // 2) Берём все дочерние DOM-узлы topG.node().children
            //    Ищем последний, у которого tagName === 'path'
            const children = topG.node().children; // HTMLCollection
            let lastPathNode = null;

            // Идём с конца к началу, чтобы найти последний path
            for (let i = children.length - 1; i >= 0; i--) {
                if (children[i].tagName.toLowerCase() === 'path') {
                    lastPathNode = children[i];
                    break;
                }
            }

            if (!lastPathNode) {
                console.log("Не нашли никакого <path> внутри top-level <g>, ничего не рисуем.");
                return;
            }

            // 3) Получаем длину пути и координаты в конце
            const pathEl = lastPathNode; // DOM-узел
            const pathLength = pathEl.getTotalLength();
            const finalPoint = pathEl.getPointAtLength(pathLength);

            // 4) Рисуем кружок в координатах finalPoint.x, finalPoint.y
            //    Можно рисовать прямо в topG или в <svg> - выбор за вами
            d3.select(pathEl.parentNode) // Чтобы поместить рядом
              .append('circle')
              .attr('class', 'hl-dot')
              .attr('cx', finalPoint.x-10)
              .attr('cy', finalPoint.y-10)
              .attr('r', 4)
              .attr('fill', 'red');
        }
    });
}


    </script>
</body>
</html>
